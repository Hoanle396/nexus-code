/**
 * Smart filtering utilities for code review
 * Skip auto-generated files, docs-only changes, etc.
 */

export interface FileChangeInfo {
  filename: string;
  status: string;
  additions: number;
  deletions: number;
  changes: number;
  patch?: string;
  content?: string;
}

export class ReviewFilters {
  // Auto-generated file patterns
  private static readonly AUTO_GENERATED_PATTERNS = [
    // Package manager files
    /^package-lock\.json$/,
    /^yarn\.lock$/,
    /^pnpm-lock\.yaml$/,
    /^Gemfile\.lock$/,
    /^Cargo\.lock$/,
    /^composer\.lock$/,
    /^poetry\.lock$/,
    
    // Build outputs
    /^dist\//,
    /^build\//,
    /^out\//,
    /^target\//,
    /^\.next\//,
    /^\.nuxt\//,
    /^\.output\//,
    
    // Dependencies
    /^node_modules\//,
    /^vendor\//,
    /^venv\//,
    /^\.venv\//,
    
    // Generated code
    /\.generated\.(ts|js|tsx|jsx)$/,
    /\.g\.(ts|js|tsx|jsx)$/,
    /-generated\.(ts|js|tsx|jsx)$/,
    /^\.gradle\//,
    /^gradle\//,
    
    // IDE files
    /^\.idea\//,
    /^\.vscode\//,
    /\.iml$/,
    
    // System files
    /^\.DS_Store$/,
    /^Thumbs\.db$/,
    
    // Compiled files
    /\.min\.(js|css)$/,
    /\.bundle\.(js|css)$/,
    /\.chunk\.(js|css)$/,
    
    // Source maps
    /\.map$/,
    
    // Coverage
    /^coverage\//,
    /^\.nyc_output\//,
  ];

  // Documentation-only file patterns
  private static readonly DOC_PATTERNS = [
    /\.md$/i,
    /^docs\//i,
    /^documentation\//i,
    /^README/i,
    /^CHANGELOG/i,
    /^CONTRIBUTING/i,
    /^LICENSE/i,
    /\.txt$/i,
  ];

  // Test file patterns
  private static readonly TEST_PATTERNS = [
    /\.test\.(ts|js|tsx|jsx)$/,
    /\.spec\.(ts|js|tsx|jsx)$/,
    /^test\//,
    /^tests\//,
    /^__tests__\//,
    /^e2e\//,
    /\.e2e\.(ts|js|tsx|jsx)$/,
  ];

  /**
   * Check if file is auto-generated and should be skipped
   */
  static isAutoGenerated(filename: string): boolean {
    return this.AUTO_GENERATED_PATTERNS.some(pattern => pattern.test(filename));
  }

  /**
   * Check if file is documentation only
   */
  static isDocumentationOnly(filename: string): boolean {
    return this.DOC_PATTERNS.some(pattern => pattern.test(filename));
  }

  /**
   * Check if file is a test file
   */
  static isTestFile(filename: string): boolean {
    return this.TEST_PATTERNS.some(pattern => pattern.test(filename));
  }

  /**
   * Check if changes are whitespace/formatting only
   */
  static isWhitespaceOnly(patch: string): boolean {
    if (!patch) return false;
    
    // Remove diff headers
    const lines = patch.split('\n').filter(line => 
      !line.startsWith('@@') && 
      !line.startsWith('+++') && 
      !line.startsWith('---')
    );
    
    // Check if all changes are just whitespace
    for (const line of lines) {
      if (line.startsWith('+') || line.startsWith('-')) {
        const content = line.substring(1).trim();
        if (content.length > 0) {
          // Has actual content change
          return false;
        }
      }
    }
    
    return true;
  }

  /**
   * Filter files that should be reviewed
   */
  static filterReviewableFiles(
    files: FileChangeInfo[],
    options: {
      skipAutoGenerated?: boolean;
      skipDocs?: boolean;
      skipTests?: boolean;
      skipWhitespace?: boolean;
    } = {}
  ): FileChangeInfo[] {
    const {
      skipAutoGenerated = true,
      skipDocs = false,
      skipTests = false,
      skipWhitespace = true,
    } = options;

    return files.filter(file => {
      // Skip removed files
      if (file.status === 'removed') {
        return false;
      }

      // Skip auto-generated files
      if (skipAutoGenerated && this.isAutoGenerated(file.filename)) {
        console.log(`⏭️  Skipping auto-generated: ${file.filename}`);
        return false;
      }

      // Skip documentation files
      if (skipDocs && this.isDocumentationOnly(file.filename)) {
        console.log(`⏭️  Skipping documentation: ${file.filename}`);
        return false;
      }

      // Skip test files
      if (skipTests && this.isTestFile(file.filename)) {
        console.log(`⏭️  Skipping test file: ${file.filename}`);
        return false;
      }

      // Skip whitespace-only changes
      if (skipWhitespace && file.patch && this.isWhitespaceOnly(file.patch)) {
        console.log(`⏭️  Skipping whitespace-only changes: ${file.filename}`);
        return false;
      }

      // Skip very large files (> 1000 changes)
      if (file.changes > 1000) {
        console.log(`⏭️  Skipping large file (${file.changes} changes): ${file.filename}`);
        return false;
      }

      return true;
    });
  }

  /**
   * Get file category for logging/analytics
   */
  static getFileCategory(filename: string): string {
    if (this.isAutoGenerated(filename)) return 'auto-generated';
    if (this.isDocumentationOnly(filename)) return 'documentation';
    if (this.isTestFile(filename)) return 'test';
    
    // Determine by extension
    const ext = filename.split('.').pop()?.toLowerCase();
    if (['ts', 'tsx', 'js', 'jsx'].includes(ext || '')) return 'code';
    if (['css', 'scss', 'sass', 'less'].includes(ext || '')) return 'style';
    if (['json', 'yaml', 'yml', 'toml'].includes(ext || '')) return 'config';
    if (['png', 'jpg', 'jpeg', 'gif', 'svg', 'ico'].includes(ext || '')) return 'asset';
    
    return 'other';
  }
}
